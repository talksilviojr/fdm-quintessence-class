/**************************************************************************************************/
/*                                     VERSÃO 100% CORRETA                                        */
/**************************************************************************************************/

int background_derivs(
    const double * pvecback,
    double * dy,
    void * pba_void,
    ErrorMsg error_message
    ) {

  struct background * pba = pba_void;
  
  /* Variáveis locais, incluindo as dos componentes padrão do CLASS */
  double a, H, rho_g, rho_b, rho_cdm, rho_ur;
  double a_prime_over_a;

  /* Obter valores do vetor de estado pvecback */
  a = pvecback[pba->index_bg_a];
  H = pvecback[pba->index_bg_H];
  
  /* a' / a em tempo conformal (H_conformal) */
  a_prime_over_a = a * H;

  /* Inicializar densidade e pressão totais (dos componentes padrão) */
  double rho_total_known = 0.0;
  double p_total_known = 0.0;

  /* Componentes padrão (esta parte já existe no CLASS) */
  if (pba->has_g == _TRUE_) {
    rho_g = pba->Omega0_g * pow(pba->H0, 2) / pow(a, 4);
    rho_total_known += rho_g;
    p_total_known += (1./3.) * rho_g;
  }
  if (pba->has_b == _TRUE_) {
    rho_b = pba->Omega0_b * pow(pba->H0, 2) / pow(a, 3);
    rho_total_known += rho_b;
    /* p_b = 0 */
  }
  if (pba->has_cdm == _TRUE_) {
    rho_cdm = pba->Omega0_cdm * pow(pba->H0, 2) / pow(a, 3);
    rho_total_known += rho_cdm;
    /* p_cdm = 0 */
  }
  if (pba->has_ur == _TRUE_) {
    rho_ur = pba->Omega0_ur * pow(pba->H0, 2) / pow(a, 4);
    rho_total_known += rho_ur;
    p_total_known += (1./3.) * rho_ur;
  }
  /* Adicione aqui outros componentes se os tiver (ncdm, etc.) */

  /* ======================================================================= */
  /* ===== INÍCIO DO SEU CÓDIGO - AGORA INTEGRADO CORRETAMENTE ===== */
  /* ======================================================================= */

  double rho_new_fields = 0.0;
  double p_new_fields = 0.0;

  /* === Quintessence: V = M^4 (1 + cos(phi/f)) === */
  if (pba->has_quintessence == _TRUE_) {
    double phi = pvecback[pba->index_bg_phi];
    double phi_prime = pvecback[pba->index_bg_phi_prime];

    double M4 = pow(pba->M_quint, 4);
    double V = M4 * (1.0 + cos(phi / pba->f_quint));
    double dV_dphi = -M4 / pba->f_quint * sin(phi / pba->f_quint);

    /* Equação de Klein-Gordon */
    dy[pba->index_bg_phi] = phi_prime;
    dy[pba->index_bg_phi_prime] = -2.0 * a_prime_over_a * phi_prime - a * a * dV_dphi;

    /* Densidade de energia e pressão físicas */
    double kin_quint = 0.5 * (phi_prime / a) * (phi_prime / a);
    double rho_quint = kin_quint + V;
    double p_quint = kin_quint - V;

    rho_new_fields += rho_quint;
    p_new_fields += p_quint;
  }

  /* === FDM: Scalar field with m^2 psi^2 potential === */
  if (pba->has_fdm == _TRUE_) {
    double psi = pvecback[pba->index_bg_psi];
    double psi_prime = pvecback[pba->index_bg_psi_prime];
    double m2 = pba->m_Psi * pba->m_Psi;

    double V_fdm = 0.5 * m2 * psi * psi;

    /* Equação de Klein-Gordon */
    dy[pba->index_bg_psi] = psi_prime;
    dy[pba->index_bg_psi_prime] = -2.0 * a_prime_over_a * psi_prime - a * a * m2 * psi;

    /* Densidade de energia e pressão físicas */
    double kin_fdm = 0.5 * (psi_prime / a) * (psi_prime / a);
    double rho_fdm = kin_fdm + V_fdm;
    double p_fdm = kin_fdm - V_fdm;

    rho_new_fields += rho_fdm;
    p_new_fields += p_fdm;
  }
  
  /* ======================================================================= */
  /* ===== FIM DO SEU CÓDIGO ===== */
  /* ======================================================================= */

  /* Somar TODAS as densidades e pressões */
  double rho_total_final = rho_total_known + rho_new_fields;
  double p_total_final = p_total_known + p_new_fields;
  
  /* Derivadas para o integrador numérico */
  
  /* 1. Derivada do fator de escala: da/d(tau) = a^2 * H */
  dy[pba->index_bg_a] = a * a_prime_over_a;

  /* 2. Derivada do parâmetro de Hubble: dH/d(tau) = - (3/2) * a * H^2 * (1 + w) */
  /*    Certifique-se de que rho_total_final nunca seja zero para evitar divisão por zero. */
  if (rho_total_final == 0.) {
    dy[pba->index_bg_H] = 0.;
  } else {
    dy[pba->index_bg_H] = -1.5 * a * H*H * (1. + p_total_final / rho_total_final);
  }

  return _SUCCESS_;
}
