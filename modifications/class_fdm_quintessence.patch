/**************************************************************************************************/
/*                      background_derivs – versão ajustada para convenções do CLASS             */
/*                           Autor original: Silvio Antonio Correa Junior      */
/**************************************************************************************************/

#include <math.h>
#include <stdio.h>
#include "background.h"

/* A assinatura correta que o CLASS espera inclui 'tau' (tempo conformal). */
int background_derivs(
    double tau,
    const double * pvecback, /* vetor de valores background */
    double * dy,             /* derivadas (a preencher) */
    void * pba_void,
    ErrorMsg error_message
){
  struct background * pba = (struct background *) pba_void;

  /* Inicializações defensivas: preenche dy com zeros para evitar lixo em saída */
  if (dy != NULL) {
    for (int i = 0; i < pba->bg_size; i++) dy[i] = 0.0;
  }

  /* ---------------------------------------------------------------------- */
  /*                   Recupera variáveis de background                     */
  /* ---------------------------------------------------------------------- */

  /* índice 'index_bg_a' e 'index_bg_H' devem existir na estrutura pba.
     Aqui assumimos que index_bg_H refere-se ao Hubble *conformal* Hc = a'/a.
     Ajuste os nomes/índices se teu fork usar outra convenção. */
  double a;
  double Hc;
  if (pba->index_bg_a < 0 || pba->index_bg_H < 0) {
    class_store_error(error_message, "background_derivs: índices index_bg_a/index_bg_H não definidos.");
    return _FAILURE_;
  }
  a  = pvecback[pba->index_bg_a];
  Hc = pvecback[pba->index_bg_H];

  /* Proteções iniciais */
  if (!isfinite(a) || a <= 0.0 || !isfinite(Hc)) {
    /* define derivadas seguras e retorna sucesso para permitir que chamador trate */
    if (dy != NULL) {
      dy[pba->index_bg_a] = 0.0;
      dy[pba->index_bg_H] = 0.0;
    }
    return _SUCCESS_;
  }

  double a2 = a*a;
  double a4 = a2*a2;

  /* ---------------------------------------------------------------------- */
  /*                     Densidades "tilde" (a^4 * rho)                     */
  /* ---------------------------------------------------------------------- */

  double rho_tilde = 0.0;
  double p_tilde   = 0.0;

  /* rho_c0 = 3 H0^2 / (8πG) — o CLASS geralmente usa 8πG = 1 em muitas versões.
     Aqui implementamos um cálculo que respeita um eventual pba->G se ele existir,
     senão usamos o fallback 3*H0^2 (como em muitos forks). Ajuste conforme teu projeto. */
  double rho_c0 = 0.0;
#ifdef HAS_PBA_G
  /* Se a estrutura tiver G armazenado (nome ilustrativo), usaríamos: */
  rho_c0 = 3.0 * pba->H0 * pba->H0 / (8.0 * M_PI * pba->G);
#else
  /* Fallback: assumir unidades com 8πG = 1 (mantido para compatibilidade com muitos códigos). */
  rho_c0 = 3.0 * pba->H0 * pba->H0;
#endif

  /* ---------------------------------------------------------------------- */
  /*                            Radiação: g                                  */
  /* ---------------------------------------------------------------------- */
  if (pba->has_g == _TRUE_){
    /* para radiação: rho(a) = rho0 * a^{-4} -> a^4 rho(a) = rho0 (constante) */
    double rt = pba->Omega0_g * rho_c0;       /* a^4 * rho_g (constante) */
    rho_tilde += rt;
    p_tilde   += rt/3.0;
  }

  /* ---------------------------------------------------------------------- */
  /*                         Baryons: b                                     */
  /* ---------------------------------------------------------------------- */
  if (pba->has_b == _TRUE_){
    /* matéria não-relativística: rho(a) = rho0 * a^{-3} -> a^4 rho(a) = a * rho0 */
    double rt = pba->Omega0_b * rho_c0 * a;   /* a^4 * rho_b = a * rho0_b */
    rho_tilde += rt;
    /* pressão ≈ 0 -> p_tilde não incrementa */
  }

  /* ---------------------------------------------------------------------- */
  /*                           CDM: cdm                                     */
  /* ---------------------------------------------------------------------- */
  if (pba->has_cdm == _TRUE_){
    double rt = pba->Omega0_cdm * rho_c0 * a; /* a^4 * rho_cdm = a * rho0_cdm */
    rho_tilde += rt;
  }

  /* ---------------------------------------------------------------------- */
  /*                    Relativistic massless: ur                           */
  /* ---------------------------------------------------------------------- */
  if (pba->has_ur == _TRUE_){
    /* como radiação: a^4 * rho_ur = constante = rho0_ur */
    double rt = pba->Omega0_ur * rho_c0;
    rho_tilde += rt;
    p_tilde   += rt/3.0;
  }

  /* ---------------------------------------------------------------------- */
  /*                  Energia escura Λ (constante cosmológica)              */
  /* ---------------------------------------------------------------------- */
  if (pba->has_lambda == _TRUE_){
    /* cosmological constant: rho(a) = rho0 (constante) -> a^4 rho = a^4 * rho0 */
    double rt = pba->Omega0_lambda * rho_c0 * a4;  /* a^4 * rho_lambda */
    rho_tilde += rt;
    p_tilde   -= rt;  /* p = -rho -> a^4 p = - a^4 rho */
  }

  /* ---------------------------------------------------------------------- */
  /*                         Neutrinos massivos ncdm                        */
  /* ---------------------------------------------------------------------- */

  if (pba->has_ncdm == _TRUE_) {
    /* Verificações defensivas: os arrays rho_ncdm_bg e p_ncdm_bg devem existir e ter N_ncdm elementos.
       Estes vetores costumam ser preenchidos por outra rotina do módulo ncdm;
       aqui fazemos checks para evitar segmentation faults. */
    double rt = 0.0;
    double pt = 0.0;

    if (pba->N_ncdm > 0 && pba->rho_ncdm_bg != NULL && pba->p_ncdm_bg != NULL) {
      for (int i = 0; i < pba->N_ncdm; i++){
        /* Espera-se que cada elemento já seja a^4 * rho_ncdm e a^4 * p_ncdm */
        if (!isfinite(pba->rho_ncdm_bg[i]) || !isfinite(pba->p_ncdm_bg[i])) {
          class_store_error(error_message, "background_derivs: rho_ncdm_bg/p_ncdm_bg contém NaN/Inf.");
          return _FAILURE_;
        }
        rt += pba->rho_ncdm_bg[i];
        pt += pba->p_ncdm_bg[i];
      }
    }
    else {
      /* Se não houver dados, podemos optar por emitir um aviso (não-fatal) ou simplesmente ignorar.
         Aqui apenas não somamos nada (equivalente a não ter ncdm). */
    }

    rho_tilde += rt;
    p_tilde   += pt;
  }

  /* ---------------------------------------------------------------------- */
  /*                    CAMPOS ESCALARES CANÔNICOS                          */
  /* ---------------------------------------------------------------------- */

  /* ========================= QUINTESSENCE =============================== */

  if (pba->has_quintessence == _TRUE_) {

    /* Verificações de índices */
    if (pba->index_bg_phi < 0 || pba->index_bg_phi_prime < 0) {
      class_store_error(error_message, "background_derivs: índices do campo quintessence não definidos.");
      return _FAILURE_;
    }

    double phi       = pvecback[pba->index_bg_phi];
    double phi_prime = pvecback[pba->index_bg_phi_prime];

    /* Parâmetros do potencial: assumimos M_quint e f_quint definidos em pba */
    double M4  = pow(pba->M_quint, 4);
    double invf = 1.0 / pba->f_quint;

    double V = M4 * (1.0 + cos(phi * invf));
    double dV_dphi = - M4 * invf * sin(phi * invf);

    /* Equações em tempo conformal (Hc = a'/a) */
    dy[pba->index_bg_phi] = phi_prime;
    dy[pba->index_bg_phi_prime] =
        -2.0 * Hc * phi_prime - a2 * dV_dphi;

    /* Densidades tilde: kin ~ a^2 φ'^2 /2, V_tilde ~ a^4 V */
    double kin_tilde = 0.5 * a2 * phi_prime * phi_prime;
    double V_tilde   = a4 * V;

    rho_tilde += kin_tilde + V_tilde;
    p_tilde   += kin_tilde - V_tilde;
  }

  /* ============================== FDM =================================== */

  if (pba->has_fdm == _TRUE_) {

    if (pba->index_bg_psi < 0 || pba->index_bg_psi_prime < 0) {
      class_store_error(error_message, "background_derivs: índices do campo FDM não definidos.");
      return _FAILURE_;
    }

    double psi       = pvecback[pba->index_bg_psi];
    double psi_prime = pvecback[pba->index_bg_psi_prime];

    double m2 = pba->m_Psi * pba->m_Psi;

    double V = 0.5 * m2 * psi * psi;
    double dV_dpsi = m2 * psi;

    dy[pba->index_bg_psi] = psi_prime;
    dy[pba->index_bg_psi_prime] =
        -2.0 * Hc * psi_prime - a2 * dV_dpsi;

    double kin_tilde = 0.5 * a2 * psi_prime * psi_prime;
    double V_tilde   = a4 * V;

    rho_tilde += kin_tilde + V_tilde;
    p_tilde   += kin_tilde - V_tilde;
  }

  /* ---------------------------------------------------------------------- */
  /*                       Equações finais para a e Hc                      */
  /* ---------------------------------------------------------------------- */

  /* a' = a * Hc (tempo conformal) */
  dy[pba->index_bg_a] = a * Hc;

  /* Proteção final: se rho_tilde ou p_tilde não-numéricos, define H' = 0 e retorna. */
  if (!isfinite(rho_tilde) || !isfinite(p_tilde)) {
    dy[pba->index_bg_H] = 0.0;
    /* podemos também colocar uma mensagem não-fatal */
    return _SUCCESS_;
  }
  else {
    /* FORMATO (tempo conformal):
       Hc' = -0.5 * (a^4 rho + a^4 p) = -0.5 * (rho_tilde + p_tilde) */
    dy[pba->index_bg_H] = -0.5 * (rho_tilde + p_tilde);
  }

  return _SUCCESS_;
}
