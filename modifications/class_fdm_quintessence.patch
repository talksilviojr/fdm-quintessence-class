/**************************************************************************************************/
/*                      background_derivs - versão funcional para CLASS (corrigida)               */
/*                                Autor: Silvio Antonio Corrêa Junior                             */
/**************************************************************************************************/

#include <math.h>

/* Assume que struct background, ErrorMsg, _TRUE_, _SUCCESS_ e os index_bg_* já estão definidos
   conforme o restante do código/CLASS. */

int background_derivs(
    const double * pvecback,
    double * dy,
    void * pba_void,
    ErrorMsg error_message
) {
  struct background * pba = (struct background *) pba_void;

  /* Variáveis locais */
  double a  = pvecback[pba->index_bg_a];
  double Hc = pvecback[pba->index_bg_H];   /* Hubble conformal: a'/a */

  /* Proteções básicas */
  if (!(isfinite(a) && a > 0.0 && isfinite(Hc))) {
    dy[pba->index_bg_a] = 0.0;
    dy[pba->index_bg_H] = 0.0;
    return _SUCCESS_;
  }

  /* Potências úteis de a */
  double a2 = a * a;
  double a3 = a2 * a;
  double a4 = a2 * a2;

  /* Densidades/pressões físicas (sem fator a^2) */
  double rho_total_known = 0.0;
  double p_total_known   = 0.0;

  /* Convenção típica do CLASS: rho_c0 = 3 H0^2 (com 8πG = 1) */
  double rho_c0 = 3.0 * pba->H0 * pba->H0;

  /* Radiação (g), baryons (b), CDM (cdm), relativistic (ur) */
  if (pba->has_g == _TRUE_) {
    double rho_g = pba->Omega0_g * rho_c0 / a4;
    rho_total_known += rho_g;
    p_total_known   += (1.0/3.0) * rho_g;
  }
  if (pba->has_b == _TRUE_) {
    double rho_b = pba->Omega0_b * rho_c0 / a3;
    rho_total_known += rho_b;
    /* p_b = 0 */
  }
  if (pba->has_cdm == _TRUE_) {
    double rho_cdm = pba->Omega0_cdm * rho_c0 / a3;
    rho_total_known += rho_cdm;
    /* p_cdm = 0 */
  }
  if (pba->has_ur == _TRUE_) {
    double rho_ur = pba->Omega0_ur * rho_c0 / a4;
    rho_total_known += rho_ur;
    p_total_known   += (1.0/3.0) * rho_ur;
  }

  /* Termo cosmológica (Λ) — entra em rho, mas (rho + p) = 0, não afeta Hc' */
  if (pba->has_lambda == _TRUE_) {
    double rho_lambda = pba->Omega0_lambda * rho_c0; /* constante no tempo */
    rho_total_known += rho_lambda;
    /* p_lambda = -rho_lambda => não adiciona em (rho+p) */
  }

  /* ncdm (neutrinos massivos) – se disponível como background simples (aproximação) */
  if (pba->has_ncdm == _TRUE_) {
    /* Se houver um método/valor de rho_ncdm(a) pronto no pba, use-o aqui.
       Caso contrário, remova este bloco ou substitua pelo seu cálculo. */
    double rho_ncdm = 0.0;
    double p_ncdm   = 0.0;
    /* Exemplo (placeholder): pba->rho_ncdm_of_a(a, &rho_ncdm, &p_ncdm); */
    rho_total_known += rho_ncdm;
    p_total_known   += p_ncdm;
  }

  /* ======================================================================= */
  /* ======================== CAMPOS ESCALARES CANÔNICOS ==================== */
  /* ======================================================================= */

  double rho_new_fields = 0.0; /* físicas */
  double p_new_fields   = 0.0; /* físicas */

  /* Quintessence: V = M^4 (1 + cos(phi/f)) */
  if (pba->has_quintessence == _TRUE_) {
    double phi       = pvecback[pba->index_bg_phi];
    double phi_prime = pvecback[pba->index_bg_phi_prime];

    double M4      = pow(pba->M_quint, 4);
    double inv_f   = 1.0 / pba->f_quint;
    double V       = M4 * (1.0 + cos(phi * inv_f));
    double dV_dphi = - M4 * inv_f * sin(phi * inv_f);

    /* Equações em tempo conformal */
    dy[pba->index_bg_phi]        = phi_prime;
    dy[pba->index_bg_phi_prime]  = -2.0 * Hc * phi_prime - a2 * dV_dphi;

    /* Densidade/pressão físicas (sem multiplicar por a^2 aqui) */
    double phi_dot   = phi_prime / a;
    double kin_quint = 0.5 * phi_dot * phi_dot;
    double rho_quint = kin_quint + V;
    double p_quint   = kin_quint - V;

    rho_new_fields += rho_quint;
    p_new_fields   += p_quint;
  }

  /* FDM: V = (1/2) m^2 psi^2 */
  if (pba->has_fdm == _TRUE_) {
    double psi       = pvecback[pba->index_bg_psi];
    double psi_prime = pvecback[pba->index_bg_psi_prime];

    double m2      = pba->m_Psi * pba->m_Psi;
    double V_fdm   = 0.5 * m2 * psi * psi;
    double dV_dpsi = m2 * psi;

    /* Equações em tempo conformal */
    dy[pba->index_bg_psi]        = psi_prime;
    dy[pba->index_bg_psi_prime]  = -2.0 * Hc * psi_prime - a2 * dV_dpsi;

    /* Densidade/pressão físicas */
    double psi_dot   = psi_prime / a;
    double kin_fdm   = 0.5 * psi_dot * psi_dot;
    double rho_fdm   = kin_fdm + V_fdm;
    double p_fdm     = kin_fdm - V_fdm;

    rho_new_fields += rho_fdm;
    p_new_fields   += p_fdm;
  }

  /* Soma total física */
  double rho_total = rho_total_known + rho_new_fields;
  double p_total   = p_total_known   + p_new_fields;

  /* Derivadas de a e Hc */
  dy[pba->index_bg_a] = a * Hc;

  if (!(isfinite(rho_total) && isfinite(p_total))) {
    dy[pba->index_bg_H] = 0.0;
  } else {
    /* Hc' = - (1/2) a^2 (rho + p), com 8πG = 1 */
    dy[pba->index_bg_H] = -0.5 * a2 * (rho_total + p_total);
  }

  return _SUCCESS_;
}
