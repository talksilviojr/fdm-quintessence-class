/**************************************************************************************************/
/*                          background_derivs - versão funcional para CLASS                       */  
/*                                Autor: Silvio Antonio CorrÊa Junior                             */ 
/**************************************************************************************************/

int background_derivs(
    const double * pvecback,
    double * dy,
    void * pba_void,
    ErrorMsg error_message
    ) {

  struct background * pba = pba_void;
  
  /* Variáveis locais */
  double a, H_conf;                 /* a: scale factor; H_conf = a' / a (conformal Hubble) */
  double rho_g = 0., rho_b = 0., rho_cdm = 0., rho_ur = 0.;
  double a_prime_over_a;

  /* Obter valores do vetor de estado pvecback */
  a = pvecback[pba->index_bg_a];
  H_conf = pvecback[pba->index_bg_H];   /* em CLASS isto costuma ser a' / a (conformal H) */

  /* a' / a em tempo conformal (já é H_conf) */
  a_prime_over_a = H_conf;

  /* Inicializar densidade e pressão totais (dos componentes padrão) em unidades CLASS-like
     (consistentes com o que você soma abaixo) */
  double rho_total_known = 0.0;
  double p_total_known = 0.0;

  /* Componentes padrão (mantive sua forma original) */
  if (pba->has_g == _TRUE_) {
    rho_g = pba->Omega0_g * pow(pba->H0, 2) / pow(a, 4);
    rho_total_known += rho_g;
    p_total_known += (1.0/3.0) * rho_g;
  }
  if (pba->has_b == _TRUE_) {
    rho_b = pba->Omega0_b * pow(pba->H0, 2) / pow(a, 3);
    rho_total_known += rho_b;
    /* p_b = 0 */
  }
  if (pba->has_cdm == _TRUE_) {
    rho_cdm = pba->Omega0_cdm * pow(pba->H0, 2) / pow(a, 3);
    rho_total_known += rho_cdm;
    /* p_cdm = 0 */
  }
  if (pba->has_ur == _TRUE_) {
    rho_ur = pba->Omega0_ur * pow(pba->H0, 2) / pow(a, 4);
    rho_total_known += rho_ur;
    p_total_known += (1.0/3.0) * rho_ur;
  }
  /* Adicione aqui outros componentes se os tiver (ncdm, lambda etc.) */

  /* ======================================================================= */
  /* ===== INÍCIO DO CÓDIGO DAS FIELDS (com unidades físicas → convertidas) ===== */
  /* ======================================================================= */

  double rho_new_fields = 0.0; /* em unidades CLASS (após multiplicar por a^2) */
  double p_new_fields = 0.0;   /* em unidades CLASS (após multiplicar por a^2) */

  /* === Quintessence: V = M^4 (1 + cos(phi/f)) === */
  if (pba->has_quintessence == _TRUE_) {
    double phi = pvecback[pba->index_bg_phi];
    double phi_prime = pvecback[pba->index_bg_phi_prime];

    /* Parâmetros do potencial vindos de pba */
    double M4 = pow(pba->M_quint, 4);
    double V = M4 * (1.0 + cos(phi / pba->f_quint));
    double dV_dphi = - M4 / pba->f_quint * sin(phi / pba->f_quint);

    /* Equação de Klein-Gordon no integrador (conformal time) */
    dy[pba->index_bg_phi] = phi_prime;
    dy[pba->index_bg_phi_prime] = -2.0 * a_prime_over_a * phi_prime - a * a * dV_dphi;

    /* Densidade e pressão físicas (usando phi_dot_phys = phi_prime / a) */
    double phi_dot_phys = phi_prime / a;
    double kin_quint = 0.5 * phi_dot_phys * phi_dot_phys; /* energy density kin term (physical) */
    double rho_quint_phys = kin_quint + V;               /* rho physical */
    double p_quint_phys   = kin_quint - V;               /* p physical */

    /* Converter para unidades CLASS (muitas partes do CLASS usam a^2 * rho_physical) */
    double rho_quint_class = a * a * rho_quint_phys;
    double p_quint_class   = a * a * p_quint_phys;

    rho_new_fields += rho_quint_class;
    p_new_fields   += p_quint_class;
  }

  /* === FDM: Scalar field with m^2 psi^2 potential === */
  if (pba->has_fdm == _TRUE_) {
    double psi = pvecback[pba->index_bg_psi];
    double psi_prime = pvecback[pba->index_bg_psi_prime];
    double m2 = pba->m_Psi * pba->m_Psi;

    double V_fdm = 0.5 * m2 * psi * psi;
    double dV_dpsi = m2 * psi; /* derivada do potencial */

    /* Equação de Klein-Gordon no integrador (conformal time) */
    dy[pba->index_bg_psi] = psi_prime;
    dy[pba->index_bg_psi_prime] = -2.0 * a_prime_over_a * psi_prime - a * a * dV_dpsi;

    /* Densidade e pressão físicas */
    double psi_dot_phys = psi_prime / a;
    double kin_fdm = 0.5 * psi_dot_phys * psi_dot_phys;
    double rho_fdm_phys = kin_fdm + V_fdm;
    double p_fdm_phys   = kin_fdm - V_fdm;

    /* Converter para unidades CLASS */
    double rho_fdm_class = a * a * rho_fdm_phys;
    double p_fdm_class   = a * a * p_fdm_phys;

    rho_new_fields += rho_fdm_class;
    p_new_fields   += p_fdm_class;
  }

  /* ======================================================================= */
  /* ===== FIM DO CÓDIGO DAS FIELDS ===== */
  /* ======================================================================= */

  /* Somar TODAS as densidades e pressões (nas mesmas unidades) */
  double rho_total_final = rho_total_known + rho_new_fields;
  double p_total_final   = p_total_known + p_new_fields;

  /* ----------------------------------------------------------------------------
   * Derivadas para o integrador numérico (tempo conformal τ)
   * ----------------------------------------------------------------------------
   * 1) da/dτ = a * (a' / a) = a * H_conf
   *    (onde H_conf = a' / a já está em pvecback[index_bg_H])
   *
   * 2) dH_conf/dτ = - (1/2) * a^2 * (rho_total + p_total)
   *    (equação de Friedmann em tempo conformal, unidades consistentes com CLASS)
   * ----------------------------------------------------------------------------
   */

  /* 1. Derivada do fator de escala: da/dτ = a * H_conf */
  dy[pba->index_bg_a] = a * H_conf;

  /* 2. Derivada do parâmetro de Hubble conformal */
  /* Pequena proteção contra divisões estranhas ou NaN: */
  if (!isfinite(rho_total_final) || !isfinite(p_total_final)) {
    /* Se algo deu errado numericamente, sinalizamos erro (ou definimos zero de forma segura) */
    dy[pba->index_bg_H] = 0.0;
  } else {
    dy[pba->index_bg_H] = -0.5 * a * a * (rho_total_final + p_total_final);
  }

  return _SUCCESS_;
}
